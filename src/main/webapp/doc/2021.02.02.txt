사용자 전체 리스트 개발 완료

사용자 페이징 처리
페이징 처리를 위해 필요한 값
1. 정렬기준 userid
2. 페이지 사이즈
3. 페이지

user/pagingUser==> 페이지, 페이지 사이즈 파라미터를 보내지 않음
				   페이지, 페이지 사이즈 파라미터
				   
	 <select id="selectPagingUser" resultType="userVo" parameterType="pageVo">
  	SELECT *
	FROM
		(SELECT ROWNUM rn, a.*
	FROM
   		 (SELECT *
   			 FROM USERS
   			 ORDER BY userid)a
   	 WHERE ROWNUM &lt;= #{page} * #{pageSize})
	WHERE rn BETWEEN (#{page}-1) * #{pageSize}+1 AND #{page} * #{pageSize}
  </select>



@RequestParam
** 메소드 인자에서 사용가능한 어노테이션

1. 바인딩 될 파라미터 설정 (name)
	파라미터 명과 메서드 인자 명이 다를 경우 자동 바인딩이 되지 않는 문제를 해결
	파라미터 명을 명시함으로써 메소드 인자에 자동 바인딩 될 수 있도록 설정
	
2. 파라미터가 존재하지 않을 경우 기본 값 설정 (defaultValue)
   파라미터가 존재하지 않을 경우, 메소드 인자를 primitive type으로 선언한 경우 에러 발생
   	==> defaultValue 설정으로 에러 방지 가능
   	
3. 파라미터 존재 여부 설정 (required, 기본값은 true)
   파라미터가 반드시 필요한지 여부를 설정
   단, defaultValue 설정시 자동으로 false로 설정됨 
   
   
@ModelAttribute
  - 생각보다 사용빈도가 많지 않지만 알고 있으면 좋음 
사용방법

1. @RequestMapping 어노테이션이 붙은 메소드가 실행 되기 전에 먼저 실행되고 해당 메소드가 리턴하는 값을 Model 객체에 넣어준다
  
   @ModelAttribute
   public List<String> rangers(){ 
   	...
   	return list;
   }
   
   @RequestMapping("list")
   public String view(Model model){
   		return "view";
   }
   
   
   localhost/user/list ==> rangers() ==> model ==> list 객체에 자동으로 담긴다
   localhost/user/list2 ==> rangers() ==> model ==> list2 객체에 자동으로 담긴다
   
   --> 위와 비슷한 테스트 코드
   @Before ==> @Test
   @Before ==> @Test
   @Before ==> @Test
   
   
2. 파라미터 인자 
MODEL 객체에 저장된 속성을 파라미터 인자에 바인딩 가능

command 객체의 경우 @ModelAttribute 어노테이션을 적용하지 않더라도 model 객체에 자동으로 등록이 된다

@SessionAttributes
class 에 적용

@ModelAttribute가 적용된 메소드가 @RequestMapping이 적용된 메소드 실행 전 항상 호출되는 부하를 줄이는 것이 목적      

최초 1회에 대해서는 @ModelAttribute가 적용된 메소드를 호출하여 해당 속성 값을 세션에 적용

그 이후 호출에 대해서는 세션에 저장된 값을 사용하여 @ModelAttribute 메소드가 적용된 로직이 반복 호출 되는 것을 방지
==> cache -  
* junit에 테스트 하기 어려움(상황에 대한 테스트를 못하고 반복적으로 호출해야된다) -> 웹브라우저로 테스트 해야됨  
   

@PathVariable : uri의 일부를 메소드 인자로 바인딩 ** (잘 기억해두기)
사용 : 메소드 인자 
1. @RequestMapping path 설정시 어떤 부분을 가져올 지 표현
	==> @RequestMapping("hello/{path}")
2. 메소드 인자에 @PathVaribale을 통해 가져올 값을 바인딩
	
	public String view(@PathVariable("path") String path){
	
	}

@RequestParam : 파라미터를 메소드 인자로 값을 바인딩 할 때 사용
@RequestHeader : 헤더 정보를 메소드 인자로 바인딩 할 때 사용



파일 업로드 작업 내용
1. 서블릿
 . form 태그 enctype = "mutipart/form-data"
 . form 태그 method = "post"
 . 서블릿 @MultipartConfig
 
 	파일정보 얻어오기 : Part part = request.getPart();
 	- FileUtil 을 사용하여 헤더 정보
 	- Cookie를 사용 
 
2. spring
 . form 태그 enctype = "mutipart/form-data"
 . form 태그 method = "post"
 . <input type="file"/>
 .  ****multipartResolver라는 스프링 빈 등록(이름이 정해짐)  - 빈은 <bean> @Bean
 . conversionService(1월 29일) - 와 같이 이름이 정해져 있다
 --> CommonsMultipartResolver
 
 	파일정보 : MultipartFile 
 
 부모
 자식 (application-context.xml - web.xml에서 찾으면 된다  )
 
 
 @RequestPart  - 파일 업로드 : @RequestParam과 유사 
 
 복수 파라미터 전송
 메소드 인자로 List --> List<String> 인자 x
 메소드 인자로 배열 --> String[] 인자 O
 메소드 인자로 리스트를 필드로 하는 command 객체 --> UsersVo userVo O
 
 public UsersVo {
 	private List<String> userids; 
 	private List<String> usernms; 
 }
 
 
Spring Mvc 실습
jsp로 만든 것을 spring으로 변환하기
1. 사용자 상세 페이지 (제외사항 : 사용자 사진, 엑스 박스로 떠도 상관없음)
2. 사용자 수정 페이지 ( 파일 업로드까지 전체 이관)
3. 사용자 등록 페이지 ( 파일 업로드까지 전체 이관)
4. 사용자 삭제 기능 (전체 이관)
5. 테스트 코드 작성 

